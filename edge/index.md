# ブラウザメモリ管理学習ガイド

このドキュメントでは、Edgeブラウザにおけるメモリ管理の仕組みと、このアプリケーションを使った学習方法について解説します。NgRxの状態管理を学ぶ上で重要なブラウザのメモリ管理の基礎知識を身につけることを目的としています。

## 目次

1. [ブラウザのメモリ管理の基本](#ブラウザのメモリ管理の基本)
2. [JavaScriptのメモリモデル](#javascriptのメモリモデル)
3. [ガベージコレクション](#ガベージコレクション)
4. [メモリリーク](#メモリリーク)
5. [アプリケーションの使い方](#アプリケーションの使い方)
6. [NgRxとメモリ管理の関係](#ngrxとメモリ管理の関係)

## ブラウザのメモリ管理の基本

ブラウザ（Edge/Chrome）は、JavaScriptコードを実行するためにメモリを割り当て、管理します。このメモリ管理は主に以下の要素で構成されています：

### JavaScriptエンジン（V8）のメモリ構造

Edgeブラウザは、Chromiumベースになってから、GoogleのV8 JavaScriptエンジンを使用しています。V8エンジンのメモリは主に以下の領域に分かれています：

1. **ヒープメモリ**：オブジェクトやデータ構造を格納する動的メモリ領域
   - **若いオブジェクト領域（New Space）**：新しく作成されたオブジェクトが最初に配置される領域
   - **古いオブジェクト領域（Old Space）**：長期間生存しているオブジェクトが移動される領域

2. **スタックメモリ**：関数呼び出しやローカル変数を管理するための領域

### メモリ制限

ブラウザには、単一のタブやウェブページが使用できるメモリ量に制限があります。これは`performance.memory.jsHeapSizeLimit`で確認できます。この制限を超えると、ブラウザはタブをクラッシュさせたり、「Aw, Snap!」などのエラーを表示したりすることがあります。

## JavaScriptのメモリモデル

JavaScriptは高水準言語であり、メモリ管理は自動的に行われます。開発者は明示的にメモリを確保・解放する必要はありませんが、メモリの使われ方を理解することは重要です。

### 値型とオブジェクト型

JavaScriptのデータ型は大きく分けて以下の2種類があります：

1. **プリミティブ型（値型）**：
   - 数値（Number）
   - 文字列（String）
   - 真偽値（Boolean）
   - null
   - undefined
   - Symbol
   - BigInt

2. **オブジェクト型（参照型）**：
   - オブジェクト（Object）
   - 配列（Array）
   - 関数（Function）
   - 日付（Date）
   - 正規表現（RegExp）
   - Map、Set、WeakMap、WeakSet など

プリミティブ型はスタックに直接値が格納されますが、オブジェクト型はヒープに格納され、変数にはそのメモリアドレス（参照）が格納されます。

### 参照の仕組み

JavaScriptでは、オブジェクトは参照によって管理されます。

```javascript
// 例：参照の仕組み
let obj1 = { name: "テスト" }; // 新しいオブジェクトがヒープに作成される
let obj2 = obj1; // obj2はobj1と同じオブジェクトを参照する

obj2.name = "変更後"; // obj1.nameも変更される
console.log(obj1.name); // "変更後"
```

## ガベージコレクション

ガベージコレクション（GC）は、不要になったメモリを自動的に解放するプロセスです。

### 到達可能性（Reachability）

JavaScriptのGCは「到達可能性」に基づいています。つまり、グローバルオブジェクト（windowなど）から直接または間接的に参照されているオブジェクトは「到達可能」とみなされ、それ以外は「到達不可能」とみなされてガベージコレクションの対象になります。

```javascript
// 例：到達可能性
let user = { name: "ユーザー" }; // オブジェクトは到達可能
user = null; // オブジェクトは到達不可能になり、GCの対象になる
```

### V8のガベージコレクションアルゴリズム

V8エンジンは主に2つのガベージコレクションアルゴリズムを使用しています：

1. **Scavenge（Minor GC）**：若いオブジェクト領域で頻繁に実行される高速なGC
2. **Mark-and-Sweep（Major GC）**：古いオブジェクト領域で実行される、より徹底的なGC

これらのGCは自動的に実行され、開発者が直接制御することはできませんが、メモリ使用パターンを最適化することで間接的に影響を与えることができます。

## メモリリーク

メモリリークとは、不要になったオブジェクトがガベージコレクションされずにメモリに残り続ける状態です。

### 一般的なメモリリークの原因

1. **未解放のイベントリスナー**：
   ```javascript
   // 問題のあるコード
   function setupListener() {
     const button = document.getElementById('button');
     const data = new Array(10000); // 大きなデータ
     
     button.addEventListener('click', function() {
       console.log(data.length); // dataへの参照を保持
     });
   }
   ```

2. **循環参照**：
   ```javascript
   // 循環参照の例
   function createCircularReference() {
     let obj1 = {};
     let obj2 = {};
     
     obj1.ref = obj2; // obj1はobj2を参照
     obj2.ref = obj1; // obj2はobj1を参照
     
     return "完了"; // obj1とobj2への外部参照がなくなるが、互いに参照し合っている
   }
   ```

3. **クロージャによる意図しない参照の保持**：
   ```javascript
   // クロージャによるメモリリーク
   function createLeakyFunction() {
     const largeData = new Array(1000000);
     
     return function() {
       // この関数はlargeDataへの参照を保持し続ける
       return largeData[0];
     };
   }
   ```

4. **グローバル変数の過剰な使用**：
   ```javascript
   // グローバル変数によるメモリリーク
   function processData() {
     window.cachedData = new Array(1000000); // グローバルに保存
   }
   ```

### メモリリークの検出と修正

メモリリークを検出するには、Chrome/EdgeのDevToolsのMemoryパネルを使用します。主に以下の方法があります：

1. **ヒープスナップショット**：メモリ内のオブジェクトの状態を記録
2. **アロケーションタイムライン**：時間経過に伴うメモリ割り当ての変化を記録
3. **アロケーションプロファイリング**：メモリ割り当てを関数単位で記録

## アプリケーションの使い方

このアプリケーションでは、以下の3つの実験を通じてブラウザのメモリ管理を学ぶことができます。

### 1. 基本的なメモリ割り当て

「オブジェクト作成」ボタンをクリックすると、大きなオブジェクト（約1MB）が10個作成され、メモリ使用量が増加します。「オブジェクトクリア」ボタンをクリックすると、これらのオブジェクトへの参照が解放され、次回のガベージコレクション時にメモリが解放される可能性があります。

この実験では、オブジェクトの作成とメモリ割り当ての基本的な仕組みを確認できます。

### 2. メモリリーク実験

「メモリリーク開始」ボタンをクリックすると、1秒ごとに大きなデータ構造を持つクロージャが作成され、それらへの参照が保持され続けます。これにより、メモリ使用量が徐々に増加していきます。「メモリリーク停止」ボタンをクリックすると、新たなメモリリークの発生は止まりますが、既に作成されたオブジェクトは参照が保持されたままなので、メモリは解放されません。

この実験では、クロージャや循環参照によるメモリリークの発生メカニズムを確認できます。

### 3. ガベージコレクション

「GCオブジェクト作成」ボタンをクリックすると、大きなオブジェクトが20個作成されます。「参照解放」ボタンをクリックすると、これらのオブジェクトへの参照が解放され、ガベージコレクションの対象になります。「GC実行ヒント」ボタンをクリックすると、ガベージコレクションが実行される可能性が高まります（ただし、ブラウザが必ずGCを実行するわけではありません）。

この実験では、参照の解放とガベージコレクションの関係を確認できます。

## NgRxとメモリ管理の関係

NgRxは、Angularアプリケーションの状態管理のためのライブラリです。NgRxを効果的に使用するためには、JavaScriptのメモリ管理の理解が重要です。

### NgRxのステート管理とメモリ

NgRxでは、アプリケーションの状態（State）は不変（Immutable）オブジェクトとして管理されます。状態が更新されるたびに、新しいオブジェクトが作成されます。

```typescript
// NgRxの状態更新の例
export function reducer(state: State, action: Action): State {
  switch (action.type) {
    case 'ADD_ITEM':
      // 新しい状態オブジェクトを作成（元の状態は変更しない）
      return {
        ...state,
        items: [...state.items, action.payload]
      };
    default:
      return state;
  }
}
```

この不変性アプローチは、状態の予測可能性と追跡可能性を向上させますが、多くの一時オブジェクトが作成されることになります。

### メモリ効率の良いNgRxの使用法

1. **セレクターの最適化**：
   - メモ化されたセレクターを使用して不要な再計算を避ける
   - `createSelector`を使用して派生状態を効率的に計算する

2. **状態の正規化**：
   - 深くネストされた状態構造を避ける
   - エンティティパターンを使用してデータを正規化する

3. **効率的なアクション設計**：
   - 細かすぎるアクションを避け、関連する状態更新をまとめる
   - 不要なアクションディスパッチを減らす

4. **Effects の適切な管理**：
   - 未使用のEffectsをアンサブスクライブする
   - 長時間実行されるObservableを適切に完了させる

### メモリリークの防止

NgRxアプリケーションでよくあるメモリリークの原因：

1. **未解放のSubscription**：
   ```typescript
   // 問題のあるコード
   export class MyComponent {
     constructor(private store: Store<AppState>) {
       // サブスクリプションが解放されない
       this.store.select(selectData).subscribe(data => {
         this.processData(data);
       });
     }
   }
   
   // 修正例
   export class MyComponent implements OnDestroy {
     private subscription: Subscription;
     
     constructor(private store: Store<AppState>) {
       this.subscription = this.store.select(selectData).subscribe(data => {
         this.processData(data);
       });
     }
     
     ngOnDestroy() {
       // コンポーネント破棄時にサブスクリプションを解放
       this.subscription.unsubscribe();
     }
   }
   ```

2. **大きな状態オブジェクト**：
   - 必要最小限の状態だけを保存する
   - 大きなデータ構造はキャッシュや遅延読み込みを検討する

## まとめ

ブラウザのメモリ管理を理解することは、効率的なNgRxアプリケーションを構築するための基礎となります。このアプリケーションを通じて、メモリ割り当て、ガベージコレクション、メモリリークの基本的な概念を学ぶことができます。

これらの知識を活かして、メモリ効率の良いNgRxアプリケーションを設計・実装しましょう。
