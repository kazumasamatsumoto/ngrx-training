/**
 * Chapter 7: メモ化（Memoization）
 *
 * このファイルでは、パフォーマンス最適化のための重要な技術である「メモ化」を示しています。
 * メモ化とは、関数の結果をキャッシュし、同じ入力に対して再計算を避ける技術です。
 *
 * ReduxやNgRxでは、セレクタ関数のメモ化によって、状態の派生データを効率的に計算します。
 * これにより、不要な再計算を避け、アプリケーションのパフォーマンスを向上させます。
 *
 * なぜメモ化が重要なのか？
 *
 * 【計算コストの削減】
 * 現代のWebアプリケーションでは、状態から派生するデータの計算が頻繁に行われます。
 * 例えば、フィルタリングされたリスト、集計値、変換されたデータなどです。これらの
 * 計算は、特に大量のデータを扱う場合、非常にコストが高くなる可能性があります。
 *
 * メモ化を使用すると、入力が変わらない限り、これらの計算結果をキャッシュして再利用できます。
 * これにより、同じ入力に対する不要な再計算を避け、アプリケーションの応答性を大幅に向上させます。
 *
 * 【状態管理との相性】
 * ReduxやNgRxなどの状態管理ライブラリでは、イミュータブルな状態更新と参照比較を
 * 使用しています。これはメモ化と非常に相性が良いです。なぜなら：
 *
 * 1. 状態が変更されていない場合、参照が同じままなので、メモ化された関数は
 *    キャッシュされた結果を返すことができます。
 *
 * 2. 状態の一部だけが変更された場合でも、変更されていない部分の参照は同じままなので、
 *    その部分に依存する計算だけを再実行すればよいです。
 *
 * 【リアクティブな更新の効率化】
 * 特にUIフレームワークでは、状態の変更に応じてUIを更新する必要があります。
 * メモ化されたセレクタを使用することで、状態の変更が実際に関連するUIコンポーネントに
 * 影響する場合にのみ、再計算と再レンダリングが行われるようになります。
 *
 * これにより、大規模なアプリケーションでも高いパフォーマンスを維持できます。
 * 例えば、1000項目のリストがあり、そのうち1項目だけが変更された場合、
 * メモ化により変更された項目だけを効率的に更新できます。
 */

// 基本的なメモ化関数
// この関数は、任意の関数をメモ化（結果をキャッシュ）するためのヘルパー関数です
function memoize(fn) {
  const cache = new Map(); // 結果をキャッシュするためのMap

  // クロージャを返す
  return function (...args) {
    // 引数をキーとして使用するために文字列化
    const key = JSON.stringify(args);

    // キャッシュにヒットした場合は、計算せずに結果を返す
    if (cache.has(key)) {
      console.log(`キャッシュヒット: ${key}`);
      return cache.get(key);
    }

    // キャッシュミスの場合は、関数を実行して結果をキャッシュ
    console.log(`キャッシュミス: ${key} - 計算を実行`);
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// 計算コストの高い関数（例: フィボナッチ数列）
// この関数は再帰的に呼び出されるため、メモ化なしでは指数関数的に遅くなります
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2); // 再帰呼び出し
}

// メモ化されたフィボナッチ関数
// 同じnに対する計算結果をキャッシュすることで、計算量を大幅に削減
const memoizedFibonacci = memoize(function (n) {
  if (n <= 1) return n;
  return memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2); // メモ化された関数を再帰呼び出し
});

// 実行例と性能比較
console.log("--- 通常のフィボナッチ関数 ---");
console.time("通常のフィボナッチ");
console.log(`fibonacci(10) = ${fibonacci(10)}`);
console.timeEnd("通常のフィボナッチ");

console.log("\n--- メモ化されたフィボナッチ関数（1回目） ---");
console.time("メモ化されたフィボナッチ（1回目）");
console.log(`memoizedFibonacci(10) = ${memoizedFibonacci(10)}`);
console.timeEnd("メモ化されたフィボナッチ（1回目）");

console.log("\n--- メモ化されたフィボナッチ関数（2回目） ---");
console.time("メモ化されたフィボナッチ（2回目）");
console.log(`memoizedFibonacci(10) = ${memoizedFibonacci(10)}`);
console.timeEnd("メモ化されたフィボナッチ（2回目）");

// 計算コストの高い関数の例（配列の要素の二乗和を計算）
function calculateSquareSum(numbers) {
  console.log(`calculateSquareSum が呼び出されました。入力: [${numbers}]`);
  
  // 計算処理が重いことをシミュレートするため、少し待機
  const startTime = Date.now();
  while (Date.now() - startTime < 100) {
    // 100ミリ秒待機（実際の重い計算処理をシミュレート）
  }
  
  // 各要素を二乗して合計する
  return numbers.reduce((sum, n) => {
    const square = n * n;
    console.log(`${n}の二乗: ${square}`);
    return sum + square;
  }, 0);
}

// メモ化された計算関数
const memoizedSquareSum = memoize(calculateSquareSum);

/**
 * メモ化の効果と原理の実演
 * 
 * 【メモ化の効果】
 * 1回目の呼び出し: 実際に計算処理が実行されます。
 * 2回目の呼び出し: 同じ入力に対しては計算処理は実行されず、キャッシュから結果が返されます。
 * 
 * 【メモ化の原理】
 * 1. 関数が呼び出されると、まず引数（入力値）をキーとしてキャッシュを検索します。
 * 2. キャッシュにヒットした場合（同じ引数で以前に呼び出された場合）:
 *    - 計算処理をスキップし、保存されていた結果をそのまま返します。
 *    - これにより計算コストを大幅に削減できます。
 * 3. キャッシュにヒットしなかった場合（初めての引数の組み合わせ）:
 *    - 実際に計算処理を実行します。
 *    - 結果をキャッシュに保存し、将来の同じ入力に備えます。
 *    - 結果を呼び出し元に返します。
 * 
 * 【技術的な実装】
 * - クロージャを使用して、関数の外部にキャッシュ（Map）を保持します。
 * - 引数をJSON文字列化してキャッシュのキーとして使用します。
 * - 関数の純粋性（同じ入力に対して常に同じ出力を返すこと）が重要です。
 */

// 同じ入力で2回呼び出し、メモ化の効果を確認
const testArray = [1, 2, 3, 4, 5];

console.log("\n--- メモ化された計算関数のデモ ---");
console.log("1回目の呼び出し（計算処理が実行される）:");
console.time("1回目の計算時間");
const result1 = memoizedSquareSum(testArray);
console.timeEnd("1回目の計算時間");
console.log(`結果: ${result1}`);

console.log("\n2回目の呼び出し（キャッシュから結果が取得される）:");
console.time("2回目の計算時間");
const result2 = memoizedSquareSum(testArray);
console.timeEnd("2回目の計算時間");
console.log(`結果: ${result2}`);

console.log("\n異なる入力での呼び出し（新たに計算処理が実行される）:");
console.time("異なる入力の計算時間");
const result3 = memoizedSquareSum([2, 3, 4, 5, 6]);
console.timeEnd("異なる入力の計算時間");
console.log(`結果: ${result3}`);

// 状態管理におけるメモ化の例
// これは、ReduxやNgRxのセレクタ関数に相当するものです
const expensiveCalculation = (state) => {
  console.log("高コストな計算を実行...");
  // 実際のアプリケーションでは、ここで複雑な計算を行う
  // 例: フィルタリング、ソート、集計など
  return state.numbers.reduce((sum, n) => sum + n, 0);
};

// 計算関数をメモ化
const memoizedCalculation = memoize(expensiveCalculation);

// 異なる状態オブジェクトでテスト
const state1 = { numbers: [1, 2, 3, 4, 5] };
const state2 = { numbers: [1, 2, 3, 4, 5] }; // 内容は同じだが異なるオブジェクト
const state3 = { numbers: [1, 2, 3, 4, 5, 6] }; // 異なる内容

console.log("\n--- 状態管理におけるメモ化の例 ---");
console.log("state1の合計:", memoizedCalculation(state1)); // 初回計算
console.log("state2の合計:", memoizedCalculation(state2)); // キャッシュから取得（同じ内容なので）
console.log("state3の合計:", memoizedCalculation(state3)); // 再計算（内容が異なるため）

/**
 * メモ化の重要なポイント:
 *
 * 1. パフォーマンス最適化: 同じ入力に対する再計算を避けることで、パフォーマンスを向上
 * 2. 参照の同一性: JSONシリアライズによるキャッシュキーの生成は、オブジェクトの内容が同じでも
 *    参照が異なる場合に別のキーとして扱われる可能性がある
 * 3. 副作用: メモ化は純粋関数（同じ入力に対して常に同じ出力を返し、副作用がない関数）に対してのみ有効
 * 4. メモリ使用量: キャッシュはメモリを消費するため、無限に大きくなる可能性がある場合は
 *    キャッシュサイズの制限やLRU（Least Recently Used）などの戦略が必要
 *
 * ReduxやNgRxでは、createSelectorやcreateFeatureSelectorなどの関数を使用して
 * メモ化されたセレクタを作成します。これらは内部的に同様のメモ化メカニズムを使用しています。
 */

/**
 * クロージャ（Closure）について:
 *
 * クロージャとは、関数が自身の外部のスコープにある変数を参照できる機能です。
 * JavaScriptでは、関数が別の関数の内部で定義され、その外側の関数のスコープにある
 * 変数にアクセスできる仕組みを指します。
 *
 * 【クロージャの特徴】
 * 1. 関数内で定義された関数（内部関数）が、外部関数のスコープにある変数を参照できる
 * 2. 外部関数の実行が終わった後も、内部関数は外部関数のスコープにある変数への参照を保持する
 * 3. これにより、「状態を持った関数」を作成することができる
 *
 * 【クロージャの利点】
 * 1. データのカプセル化: 変数をプライベートに保ち、特定の関数からのみアクセス可能にできる
 * 2. 状態の保持: 関数呼び出し間で状態を維持できる（例: カウンタ、キャッシュなど）
 * 3. 高階関数の実装: 関数を返す関数を作成する際に非常に有用
 *
 * 【メモ化とクロージャの関係】
 * メモ化の実装では、クロージャが重要な役割を果たします。下記のmemoize関数では：
 * - 外部関数（memoize）内でcacheという変数を定義
 * - 内部関数（無名関数）がこのcache変数にアクセスし、結果をキャッシュ
 * - 内部関数が返されても、cacheへの参照は保持され続ける
 * - これにより、関数呼び出し間でキャッシュを維持することができる
 *
 * クロージャは、ReduxやNgRxなどの状態管理ライブラリでも広く活用されており、
 * 特にセレクタ関数やミドルウェアの実装において重要な役割を果たしています。
 */
